### 第七章 程序架构

**目标**：从“编译、加载、运行”三条主线完整理解 Mindustry 的程序结构，帮助读者在需要深改或排错时能快速定位入口与责任边界。

#### 7.1 游戏编译流程及贴图生成机制

##### 7.1.1 Gradle 任务链与模块依赖拓扑
##### 7.1.2 资源与代码的分离：构建产物与中间目录
##### 7.1.3 贴图与图集生成：`tools/` 的职责与输入输出
##### 7.1.4 `@Load` 的解析与贴图绑定时机
##### 7.1.5 开发构建与发行构建的差异
##### 7.1.6 构建失败的常见原因与定位路径
##### 7.1.7 模组在构建流程中的插入点

#### 7.2 编译期 ECS 架构

##### 7.2.1 注解处理器与代码生成总体流程
##### 7.2.2 组件组合与实体接口的生成规则
##### 7.2.3 `@Component` 与 `@EntityDef` 的真实含义
##### 7.2.4 同步字段与插值：`@SyncField`、`@SyncLocal`、`@NoSync`
##### 7.2.5 实体池化、复用与生命周期
##### 7.2.6 组件之间的依赖与 `@Import` 的作用
##### 7.2.7 `GroupDef` 与实体分组的更新策略

#### 7.3 游戏内享元-实体架构

##### 7.3.1 `Content` 与运行时实体的边界
##### 7.3.2 `Block` 与 `Building` 的分工
##### 7.3.3 `UnitType` 与 `Unit` 的关系
##### 7.3.4 `BulletType` 与 `Bullet` 的关系
##### 7.3.5 共享数据与实例化成本控制
##### 7.3.6 运行时状态如何挂接到静态内容
##### 7.3.7 对象池与内存复用策略

#### 7.4 原版游戏启动流程

##### 7.4.1 客户端、服务器与移动端入口差异
##### 7.4.2 模块初始化顺序与关键单例装配
##### 7.4.3 资源加载、贴图装箱与 UI 初始化
##### 7.4.4 `Vars` 初始化时机与依赖顺序
##### 7.4.5 事件触发点与启动阶段可用对象
##### 7.4.6 启动阶段常见空指针与规避方式

#### 7.5 世界（World）与格子（Tiles）

##### 7.5.1 地图加载流程与事件时序
##### 7.5.2 `Tile` 与 `Building` 的绑定关系
##### 7.5.3 `floor`、`overlay`、`block` 的三层结构
##### 7.5.4 坐标换算：世界坐标与格子坐标
##### 7.5.5 邻接与更新：`updateProximity` 与缓存
##### 7.5.6 多格建筑的占位与旋转逻辑
##### 7.5.7 世界边界与物理范围

#### 7.6 Vars 中的实用单例

##### 7.6.1 `Vars` 的设计定位与使用场景
##### 7.6.2 常用模块：`content`、`world`、`state`、`renderer`、`ui`
##### 7.6.3 网络相关单例与客户端/服务器差异
##### 7.6.4 资源与文件系统相关入口
##### 7.6.5 初始化过早访问的风险与解决方案
##### 7.6.6 在模组中写可用的访问包装

#### 7.7 I/O、同步与网络

##### 7.7.1 保存与读取：`SaveIO` 与版本兼容
##### 7.7.2 序列化协议：`Writes`、`Reads` 与 `TypeIO`
##### 7.7.3 网络同步字段与插值策略
##### 7.7.4 远程调用：`@Remote` 与自动生成的网络包
##### 7.7.5 客户端与服务器的职责划分
##### 7.7.6 网络事件与断线重连的处理路径
##### 7.7.7 模组自定义数据的持久化方案

#### 7.8 碰撞系统与物理模拟

##### 7.8.1 命中体积与碰撞接口体系
##### 7.8.2 物理更新与位置修正流程
##### 7.8.3 单位碰撞与路径阻塞规则
##### 7.8.4 子弹与建筑的碰撞判定
##### 7.8.5 穿透、范围伤害与碰撞缓存
##### 7.8.6 地形与液体对移动的影响
##### 7.8.7 物理调试与碰撞可视化

#### 7.9 模组加载流程

##### 7.9.1 `Mods` 模块的整体职责
##### 7.9.2 文件树与资源发现：`Vars.tree`
##### 7.9.3 Java 模组与脚本模组的加载差异
##### 7.9.4 JSON 内容解析与覆盖规则
##### 7.9.5 加载顺序与依赖关系
##### 7.9.6 模组冲突与命名空间策略
##### 7.9.7 典型加载错误与排查路径

#### 7.10 原版逻辑系统（Logic）

##### 7.10.1 主循环与更新节奏
##### 7.10.2 波次系统与刷怪路径
##### 7.10.3 规则系统与难度参数
##### 7.10.4 任务与目标更新流程
##### 7.10.5 事件触发点与常用挂钩位置
##### 7.10.6 AI 更新与团队逻辑
##### 7.10.7 性能热点与优化原则

#### 7.11 游戏的输入与控制

##### 7.11.1 桌面端与移动端输入架构
##### 7.11.2 玩家单位控制与指令系统
##### 7.11.3 建造、拆除与蓝图输入链路
##### 7.11.4 选择与交互：点击、拖拽与长按
##### 7.11.5 输入事件与 UI 交互的边界
##### 7.11.6 逻辑控制与自动控制的切换点

#### 7.12 利用反射和方法句柄应对游戏的不良封装

##### 7.12.1 反射与方法句柄的基本用法
##### 7.12.2 访问私有字段与私有方法的策略
##### 7.12.3 版本兼容与降级方案
##### 7.12.4 缓存与性能：避免重复查找
##### 7.12.5 安全边界与可维护的封装方式
##### 7.12.6 何时应该选择注入而非反射

建议写法：每小节都给出“入口类 + 关键方法 + 典型调用链 + 常见坑”，并配一段最小代码示例或伪代码说明。
